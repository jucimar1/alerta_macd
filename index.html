<script>
    const CONFIG = {
        symbol: 'SOLUSDT',
        interval: '1m',
        initialBalance: 10000,
        apiUrl: 'https://api.binance.com',
        wsUrl: 'wss://://stream.binance.com',
        bbPeriod: 20, // Período para as Bandas de Bollinger
        bbStdDev: 2    // Desvio Padrão (2 desvios é o padrão)
    };

    let state = {
        balance: CONFIG.initialBalance,
        lastPrice: 0,
        history: [],
        currentSup: 0,
        currentRes: 0
    };
    
    // Referências de UI
    const priceEl = document.getElementById('price');
    const supEl = document.getElementById('sup');
    const resEl = document.getElementById('res');
    const dSupEl = document.getElementById('dSup');
    const balanceEl = document.getElementById('balance');

    // 1. Configuração do Gráfico (Lightweight Charts)
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout: { background: { color: '#0b0e11' }, textColor: '#848e9c' },
        grid: { vertLines: { color: '#1f2226' }, horzLines: { color: '#1f2226' } },
        timeScale: { timeVisible: true, secondsVisible: false }
    });

    const candleSeries = chart.addCandlestickSeries({ upColor: '#0ecb81', downColor: '#f6465d' });
    
    // Adiciona a série de VOLUME em um painel separado
    const volumeSeries = chart.addHistogramSeries({
        color: '#181a20',
        priceScaleId: 'volume', // ID da escala de preço para o volume
    });

    // Adiciona as linhas das Bandas de Bollinger (Middle, Upper, Lower)
    const bbMiddle = chart.addLineSeries({ color: '#f0b90b', lineWidth: 1, lineStyle: 0 }); // Laranja (SMA)
    const bbUpper = chart.addLineSeries({ color: '#f6465d', lineWidth: 1, lineStyle: 2 }); // Vermelho tracejado
    const bbLower = chart.addLineSeries({ color: '#0ecb81', lineWidth: 1, lineStyle: 2 }); // Verde tracejado


    // 2. Coleta de Dados Históricos (REST API)
    async function fetchHistory() {
        try {
            // Ajustado para obter dados de 1m para as BBands de 20 períodos
            const res = await fetch(`${CONFIG.apiUrl}/klines?symbol=${CONFIG.symbol.toUpperCase()}&interval=${CONFIG.interval}&limit=120`);
            const rawData = await res.json();
            
            state.history = rawData.map(d => ({
                time: d / 1000, 
                open: parseFloat(d), high: parseFloat(d), low: parseFloat(d), close: parseFloat(d), volume: parseFloat(d)
            }));

            // Formatando dados de Volume para o Lightweight Charts (cor baseada na direção da vela)
            const volumeData = state.history.map((d, i) => ({
                time: d.time,
                value: d.volume,
                color: d.close >= d.open ? 'rgba(14, 203, 129, 0.4)' : 'rgba(246, 70, 93, 0.4)'
            }));

            candleSeries.setData(state.history);
            volumeSeries.setData(volumeData);
            
            calculateAndDrawBBands();
            updateTechnicalLevels();

        } catch (e) {
            console.error("Erro ao carregar histórico inicial:", e);
            priceEl.innerText = 'ERRO API';
        }
    }

    // 3. Conexão em Tempo Real (WebSocket)
    function initWebSocket() {
        const ws = new WebSocket(`${CONFIG.wsUrl}/${CONFIG.symbol.toLowerCase()}@kline_${CONFIG.interval}`);
        
        ws.onmessage = (event) => {
            const k = JSON.parse(event.data).k;
            const candle = {
                time: k.t / 1000, open: parseFloat(k.o), high: parseFloat(k.h), low: parseFloat(k.l), close: parseFloat(k.c)
            };
            
            // Atualiza o gráfico principal e o volume em tempo real
            candleSeries.update(candle);
            volumeSeries.update({
                time: candle.time,
                value: parseFloat(k.v),
                color: candle.close >= candle.open ? 'rgba(14, 203, 129, 0.4)' : 'rgba(246, 70, 93, 0.4)'
            });

            state.lastPrice = candle.close;
            priceEl.innerText = `${state.lastPrice.toFixed(2)}`;
            updateUIStats();

            if (k.x) { // Quando a vela fecha, recalcula indicadores baseados em dados fechados
                state.history.push(candle);
                if (state.history.length > 120) state.history.shift();
                calculateAndDrawBBands();
                updateTechnicalLevels();
            }
        };

        ws.onclose = () => setTimeout(initWebSocket, 5000);
    }

    // 4. Funções de Cálculo (Bollinger Bands)
    function calculateAndDrawBBands() {
        const closes = state.history.map(c => c.close);
        if (closes.length < CONFIG.bbPeriod) return;

        const bbandData = [];
        for (let i = CONFIG.bbPeriod - 1; i < closes.length; i++) {
            const periodCloses = closes.slice(i - CONFIG.bbPeriod + 1, i + 1);
            const sma = periodCloses.reduce((a, b) => a + b, 0) / CONFIG.bbPeriod;
            
            // Cálculo do Desvio Padrão
            const stdDev = Math.sqrt(periodCloses.map(x => Math.pow(x - sma, 2)).reduce((a, b) => a + b, 0) / CONFIG.bbPeriod);

            bbandData.push({
                time: state.history[i].time,
                middle: sma,
                upper: sma + stdDev * CONFIG.bbStdDev,
                lower: sma - stdDev * CONFIG.bbStdDev,
            });
        }
        
        // Atualiza as linhas no gráfico
        bbMiddle.setData(bbandData.map(d => ({ time: d.time, value: d.middle })));
        bbUpper.setData(bbandData.map(d => ({ time: d.time, value: d.upper })));
        bbLower.setData(bbandData.map(d => ({ time: d.time, value: d.lower })));
    }

    function updateTechnicalLevels() {
        const last24 = state.history.slice(-24);
        state.currentSup = Math.min(...last24.map(c => c.low));
        state.currentRes = Math.max(...last24.map(c => c.high));
        
        supEl.innerText = `${state.currentSup.toFixed(2)}`;
        resEl.innerText = `${state.currentRes.toFixed(2)}`;
    }

    function updateUIStats() {
        if(state.currentSup > 0 && state.lastPrice > 0) {
            const dist = ((state.lastPrice - state.currentSup) / state.currentSup * 100).toFixed(2);
            dSupEl.innerText = `${dist}%`;
            dSupEl.style.color = dist < 1.0 ? '#0ecb81' : '#f0b90b';
        }
    }

    // 5. Sistema de Ordens (Paper Trading)
    function trade(type) {
        // Função para os botões COMPRAR/VENDER da sua imagem
        alert(`Ordem de ${type} simulada em $${state.lastPrice.toFixed(2)}!`);
        // Lógica de saldo continua a mesma, se você quiser adicionar aqui.
    }

    // Iniciar o carregamento dos dados e a conexão em tempo real
    window.onload = () => {
        fetchHistory().then(initWebSocket);
        balanceEl.innerText = `U$ ${state.balance.toLocaleString('pt-BR', {minimumFractionDigits: 2})}`;
    };
</script>
